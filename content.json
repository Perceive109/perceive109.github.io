{"pages":[{"title":"Project Experience / 项目经历","text":"这是一个测试邮件","link":"/file/test.html"},{"title":"","text":"真帅！ 1 2 2 2 2 2 22 2 2 2 2 2 2 2 2 2 2 2 2 2","link":"/shuai/index.html"}],"posts":[{"title":"个人信息 / About ME","text":"🔗点击打开我的简历 [站点1：GitHub] 🔗点击下载我的简历↓ [站点2：阿里云] 🔷 报考信息： 🔸 目标院校：上海大学 🔸 目标专业：计算机科学与技术（081200）🔹 本科院校：上海应用技术大学 🔹 本科专业：计算机科学与技术（2019级） 🔷 个人信息： 🔹 籍贯：吉林长春🔹 政治面貌：共青团员🔹 出生日期：2001年01月09日🔹 联系方式：13844061985🔹 外语水平：CET-6 （508分通过） 🔷 教育背景： 🔗点击打开我的成绩单 🔹 专业排名：专业前3%🔹 平均绩点：主修课程 GPA 3.9/5.0 &amp; 全部课程 GPA 4.2/5.0🔹 主要课程：数据结构、操作系统、计算机组成原理、计算机网络原理、 数据库原理及应用、机器学习、机器视觉及应用、人工智能与智能决策、脑科 学及算法设计、人工智能在自动驾驶中的应用。🔹 专业证书：上海市信息技术水平C语言三级、软件测试三级；国家普通话水平测试二级甲等；🔹 毕业设计：《基于树莓派小车的 slam 程序设计与开发》 🔷 校园经历： 🔹 班级学委：主要负责协调班级同学与老师、教务之间的关系，并有序开展教学工作。🔹 学生会外联部执行负责人：负责筹办大型活动若干，代表学院与启航教育、卡西欧、抖音、农夫山泉等公司洽谈合作，达成赞助金额一万余元。在职期间个人评选为优秀负责人，所属部门评选为优秀部门。","link":"/2023/02/21/AboutMe_1/"},{"title":"项目经历 / Project Experience","text":"2023 低速无人驾驶POC算法组2023年2月加入导师项目组，主要与研究生学长交流完成毕业论文相关实验。定期参加参与“激光SLAM与IMU定位”子模块研究小组组会。 2022 “瑕”形毕露一工业界的次品清道夫项目描述：导师项目子课题，融合大数据平台，利用动态线扫相移条纹和光度立体成像形成多数据源，在保证效率的情况下满足多种不同类型、不同伤型的滚子缺陷检测。工作职责分为以下两个部分：1.完成商业计划书涉及市场分析部分的撰写、终稿排版及审查工作；2.阅读相关文献，以第一发明人完成实用新型专利一项(审查中)，该专利公开了一种多模态融合的金属工件表面缺陷检测方法，具体涉及数据增强、Yolo v5、PointNet++、Fast-CLOCs等相关算法。 2021 基于智能技术的公交车逃生窗装置及其控制系统项目描述：提出一种稳定性好、引导性强且原理简单的公交车智能窗体系统。工作职责：完成作品设计、发明的目的和基本思路等相关文稿撰写；完成实体模型搭建和电路连接。 2021 基于智能算法的布料样本自动分类系统工作职责：1. 对数据集进行数据增强；2. 应用经典图像算法，对布料进行瑕疵检测及分类。","link":"/2023/02/20/AboutMe_2_Project/"},{"title":"读研规划 / Planning for Postgraduate Study","text":"🔷 总体目标： 🔹提高自主学习与创新能力，适应技术的更新换代，做到理论学习与项目实践并重，学科内涵与学科交叉并举。🔹 学习：注重细节、保持思考、阅读文献、勤于总结、勤于交流；🔹 研究：找问题、勤思考、找方法、掌握专业知识；🔹 生活：表达、认知、逻辑、执行、锻炼、习惯、规划； 🔷 详细计划： 🔹 拟录取至开学阶段 1️⃣ 在导师允许下提前进组适应科研生活，结合个人实际情况及导师安排，对读研期间将使用的理论知识进行查漏补缺；2️⃣ 自行完成数据分析、机器学习和人工智能等研究方向的相关基础理论的学习，重点学习李航老师的《统计学习方法》和吴恩达老师的《Deep Learning》；3️⃣ 对课题组研究领域的研究现状、研究方法和手段等进行调研，为开启自己的研究工作做好准备；4️⃣ 结合实际情况做进一步远景学习规划；5️⃣ 强化学术英语基础及应用能力，提升英语听说读写能力； 🔹 研一第一学期阶段 1️⃣ 在导师的指导下制定个人培养计划，包括课程学习、文献阅读、研究生创新与实践以及学位论文等4方面内容；2️⃣ 完成研究生公共基础课及专业基础课的学习；3️⃣ 积极参与课题组各项活动，结合课题组研究方向阅读文献，定期向导师请教并汇报学习进展，做好学术积累；4️⃣ 结合实际情况做进一步远景学习规划； 🔹 研一第二学期阶段 1️⃣ 完成研究生专业必修课和专业选修课的学习，为从事研究工作奠定扎实的理论基础；2️⃣ 据课题组研究方向，在导师的指导下确定学位论文的选题范围，并开展相关基础研究或应用研究，同时积极参加相关学科竞赛和其他实践创新活动；3️⃣ 根据当前状况为研二做更细致的远景规划； 🔹 研二第一学期阶段 1️⃣ 在导师的指导下学期初完成学位论文的开题，明确研究方法、研究思路、内容框架、撰写计划、核心观点和创新环节；2️⃣ 在导师指导下围绕选题开始着手从事研究工作，完成课题相关的实验，定期向导师汇报工作进展； 🔹 研二第二学期、研三 1️⃣ 在导师的指导下凝练科研成果，在学术期刊上公开发表1-2篇高质量学术论文；2️⃣ 撰写学位论文并通过学位论文评阅与答辩。 如有不足，请不吝赐教！","link":"/2023/02/19/AboutMe_3_GraduatePlan/"},{"title":"获奖情况 / Honors and Awards","text":"🔗点击此处打开证明材料 🔷 市级荣誉： 🔹 2020-2021 学年度 十七届“挑战杯”上海市大学生课外学术科技作品竞赛中，项目《基于 智能技术的公交车逃生窗装置及其控制系统》团队荣获 “上海市三等奖” 🔹 2022-2023 学年度 第八届中国国际“互联网+”大学生创新创业大赛上海赛区中，项目 《“瑕”形毕露——工业界的次品清道夫》团队荣获“上海市银奖” 🔷 校级荣誉： 🔹 2019-2020 第一学期 荣获 “综合奖学金” 一等奖 🔹 2019-2020 第二学期 荣获 “综合奖学金” 一等奖 🔹 2020-2021 第一学期 荣获 “综合奖学金” 一等奖 🔹 2020-2021 第二学期 荣获 “综合奖学金” 二等奖 🔹 2021-2022 第一学期 荣获 “综合奖学金” 一等奖 🔹 2021-2022 第二学期 荣获 “综合奖学金” 一等奖 🔹 2022-2023 第一学期 荣获 “综合奖学金” 三等奖 🔹 2019-2020 学年度 荣获 上海应用技术大学“优秀学生干部” 荣誉称号 🔹 2019-2020 学年度 荣获 上海应用技术大学“优秀团员” 荣誉称号 🔹 2020-2021 学年度 荣获 上海应用技术大学“优秀团员” 荣誉称号 🔹 2021-2022 学年度 荣获 上海应用技术大学“优秀团员” 荣誉称号 🔹 2020-2021 学年度 荣获 上海应用技术大学“优秀学生” 荣誉称号🔹 2021-2022 学年度 荣获 上海应用技术大学“优秀学生” 荣誉称号🔹 2020-2021 学年度 上海应用技术大学“青春心向党·建功新时代”上海青年说暨团员青年学习习近平新时代中国特色社会主义思想主题征文暨演讲比赛校内选拔赛“二等奖”🔹 2020-2021 学年度 上海应用技术大学“学宪法·讲宪法”演讲比赛“优胜奖” 🔷 院级荣誉： 🔹 2019-2020 学年度 荣获 上海应用技术大学计算机学院团委学生会 “优秀干事”🔹 2020-2021 学年度 荣获 上海应用技术大学计算机学院团委学生会 “优秀部门”🔹 2020-2021 学年度 荣获 上海应用技术大学计算机学院团委学生会 “优秀负责人”🔹 2020-2021 学年度 荣获 上海应用技术大学“学习型寝室”成员🔹 2020-2021 学年度 荣获 上海应用技术大学计算机节IT技能竞赛“一等奖”","link":"/2023/02/18/AboutMe_4_Honor/"},{"title":"=====分割线=====","text":"以上内容为考研自我介绍内容，欢迎批评指正 ：）","link":"/2023/01/01/AboutMe_n_DevideLine/"},{"title":"算法笔记：蚁群算法","text":"蚁群算法：概要：主要过程： 状态转移 信息素更新 主要公式： 状态转移阶段： 为了避免残留信息素过多而淹没启发信息，在每只蚂蚁走完一步或者完成对所有n个城市的遍历(也即一个循环结束)后，要对残留信息进行更新处理。 由此，t+n时刻在路径(i,j)上的信息量可按如下规则进行调整： 逻辑模型：信息素更新模型： Python代码实现：蚁群类：蚁群类：初始化 init(self,ID)1234def __init__(self, ID): self.ID = ID # ID self.__clean_data() # 调用函数初始化所有信息 随机初始化出生点 蚁群类：初始化数据信息__clean_data()12345678910111213# 初始数据def __clean_data(self): self.path = [] # 当前蚂蚁的路径 self.total_distance = 0.0 # 当前路径的总距离 self.move_count = 0 # 移动次数 self.current_city = -1 # 当前停留的城市 self.open_table_city = [True for i in range(city_num)] # 探索城市的状态 city_index = random.randint(0, city_num - 1) # 随机初始出生点 self.current_city = city_index self.path.append(city_index) # 添加初始城市到蚂蚁路径当中 self.open_table_city[city_index] = False # 记录初始城市已经被纳入 禁忌表True=》false self.move_count = 1 # 移动次数+1 蚁群类：选择下一个城市（）123456789101112131415161718192021222324252627282930313233343536373839404142# 选择下一个城市（input self output= nextcity）def __choice_next_city(self): next_city = -1 # 初始化数据 next_city select_citys_prob = [0.0 for i in range(city_num)] # 存储去下个城市的概率 total_prob = 0.0 # 初始化数据 total_prob # 获取去下一个城市的概率 for i in range(city_num): if self.open_table_city[i]: # 查询禁忌表 try: # 异常处理 try - except # 计算概率：与信息素浓度成正比，与距离成反比 # select_citys_prob[i] ：对应算式中的分子 select_citys_prob[i] = pow(pheromone_graph[self.current_city][i], ALPHA) * pow( (1.0 / distance_graph[self.current_city][i]), BETA) # total_prob 分母 total_prob += select_citys_prob[i] except ZeroDivisionError as e: print('Ant ID: {ID}, current city: {current}, target city: {target}'.format(ID=self.ID, current=self.current_city, target=i)) sys.exit(1) # 轮盘选择城市 if total_prob &gt; 0.0: temp_prob = random.uniform(0.0, total_prob) # 在 0~total_prob 生成一个随机数（浮点） for i in range(city_num): if self.open_table_city[i]: # 如果城市i在禁忌表中 # 采用轮次相减法选择城市 temp_prob -= select_citys_prob[i] if temp_prob &lt; 0.0: # 选择城市i 退出for循环 next_city = i # 下一个城市（next_city）： i break # 未从概率产生，顺序选择一个未访问城市(应该不会出现此情况) if (next_city == -1): next_city = random.randint(0, city_num - 1) while ((self.open_table_city[next_city]) == False): # if==False,说明已经遍历过了 next_city = random.randint(0, city_num - 1) # 返回下一个城市序号 return next_city 蚁群类：计算路径距离123456789101112def __cal_total_distance(self): temp_distance = float(0.0) #用于计算和 for i in range(1, city_num): start, end = self.path[i], self.path[i - 1] temp_distance += distance_graph[start][end] # 回路 end = self.path[0] temp_distance += distance_graph[start][end] self.total_distance = temp_distance # 保存最终值 蚁群类： 移动操作1234567def __move(self, next_city): self.path.append(next_city) # 记录路径 self.open_table_city[next_city] = False # 修改禁忌表 self.total_distance += distance_graph[self.current_city][next_city] # 总距离增加（冗余） self.current_city = next_city # 修改当前城市 self.move_count += 1 # 移动次数+1 蚁群类：主函数：迭代一次1234567891011121314# 主函数：迭代一次def search_path(self): # 初始化数据 self.__clean_data() # 搜素路径，遍历完所有城市为止 while self.move_count &lt; city_num: # 移动到下一个城市 next_city = self.__choice_next_city() self.__move(next_city) # 计算路径总长度 self.__cal_total_distance()","link":"/2022/12/30/Algorithm_2_Ants/"},{"title":"算法笔记：Yolo","text":"YOLO算法： 研究首先对获取到的图像进行归一化处理，然后将训练图片送入 YOLOv5模型进行训练 Yolo算法主要是分为训练部分和检测部分。 训练部分： 图片、预测框、标签、置信度；（其信息是相对于整张图片而言） 图像和标签的处理，首先将源图像分割为 n x n的矩阵，然后根据目标的中心点位置对被分割的格子进行信息分配。最终每个格子都会得到一个向量。 检测部分： 非极大值抑制：首先找到若干预测的框框内概率最大的框，然后判断与其他框的交并比（IOU）是否大于一个阈值（比如0.5），筛选掉与该物品无关的框，保留最终的框。 最新成果：Yolo v8（ultralytics） Yolo算法：笔记2 该研究首先对获取到的图像进行归一化处理，然后将训练图片送入YOLOv5模型进行训练，得到最佳的网络权重数据，再对测试图片进行预测分析，检测流程如图1所示。实验结果表明:所提算法在检测速度和准确性方面均优于上述学者所提算法，证明了方法的有效性和实用性。 In-put、Backbone、Neck和Prediction。 Input 输入端：数据增强、图片尺寸处理、自适应锚框计算 网络模型在基础锚框的基础上训练得到预测框，并和真实框进行比较（IOU），根据差值反向更新， 迭代调整网络模型参数。 使用labelimg软件进行目标标注【标注软件】 Backbone 主干网络：Focus结构与CSP结构 Neck网络：FPN+PAN结构 FPN：自上而 下的，利用上采样的方式对信息进行传递融合，获得预测的特征图。 PAN：自底向上的特征金字塔。 Prediction 预测层：GIOU_Loss作为损失函数，有效解决了边界框不重合时问题。 YOLO算法：硕士论文笔记： 【序言】首先目标检测算法可分为两阶段算法和一阶段算法。两阶段算法基于提议的候选区域，先提取目标的候选框，再基于候选框二次修正得到分类和回归的结果；一阶段算法基于边界框回归，在产生边界框的同时进行回归和分类。常见的两阶段算法有：、SPPNet、Fast R-CNN、Faster R-CNN算法常见的一阶段算法：SSD和YOLO系列算法； 【R-CNN算法 区域卷积神经网络】R-CNN算法：首先，采用“选择性搜索[40]”算法产生若干个可能包含物体的区域；其次，利用卷积神经网络（如AlexNet[27]）在选取的区域上进行特征提取；接着使用支持向量机（SVM）[29]分类器进行分类；最后采用边界框回归的方式进行准确的定位。 Fast R-CNN算法：本质上来说，Fast R-CNN不再像R-CNN那样对每一个提议区域分别卷积，而是直接对整 张图像做卷积操作，并利用ROI池化及映射关系得到统一大小的特征，这样就减 少了大量的重复计算 YOLO： 将输入图像分成S×S个网格单元如果某类物体的中心点落在了7×7个网格单元中的某个时，那么该网格将负责预测这类物体。每一个网格单元产生B个矩形框（YOLOv1取B=2），每个矩形框预测4个位置信息值（物体中心点的坐标x, y及框的长宽w, h）和1个置 信度值c。置信度c的计算公式如公式(2.1)所示： - 其中，𝑃𝑟(𝑜𝑏𝑗𝑒𝑐𝑡)的值取0或1，即当物体的中心落在网格单元内，则置信度值为 真实框与预测框之间的IoU值；而物体中心不在该网格时，则置信度为0。 最后根据之前步骤，预测7×7×2=98个目标窗口，然后根据阈值（通常取0.2） 去除可能性比较低的目标窗口，再经过非极大值抑制（NMS）去除冗余窗口即可。 特征金字塔网络 FPN：在以往的目标检测（如Faster R-CNN）过程中，无 论是区域提议网络（RPN）还是感兴趣的区域（ROI），基本都是作用于网络的最后一层。 FPN（Feature Pyramid Network）是YOLO算法中一种用于多尺度目标检测的技术，它通过构建特征金字塔来提高检测精度。 在YOLO算法中，特征提取网络通常使用卷积神经网络（CNN）来提取图像特征。这些特征图的分辨率会随着网络深度的增加而逐渐降低。但是，低分辨率的特征图包含了大量的语义信息，而高分辨率的特征图包含了更多的细节信息。因此，如何同时利用这些不同分辨率的特征图来提高目标检测精度就成为了一个挑战。 FPN通过构建特征金字塔来解决这个问题。具体来说，它通过在不同的特征图之间添加上采样和下采样模块来实现特征金字塔的构建。上采样模块可以将低分辨率的特征图放大到与高分辨率的特征图相同的尺寸，而下采样模块则可以将高分辨率的特征图降低到与低分辨率的特征图相同的尺寸。这样，不同分辨率的特征图就可以被有效地整合到一个金字塔中，从而提高目标检测的精度。 在YOLO算法中，FPN技术通常用于检测小目标或者在图像中存在尺度变化的情况下，可以提高目标检测的精度。 路径聚合网络（PANet） PAN（Path Aggregation Network）是YOLOv3算法中一种用于多尺度目标检测的技术，它通过特征金字塔和特征融合来提高检测精度。 在YOLOv3算法中，PAN技术用于处理不同尺度的特征图，使得算法可以检测不同大小的目标。PAN网络由两部分组成：特征金字塔和特征融合。特征金字塔是一种类似于FPN的技术，它通过在不同分辨率的特征图之间进行上下采样，构建出一个多尺度的特征金字塔。而特征融合则是将不同分辨率的特征图进行融合，得到一个更加具有丰富语义信息的特征图。 具体来说，在PAN网络中，特征金字塔由一个主干网络和多个特征提取分支组成。主干网络通常使用深度残差网络（ResNet）或者密集连接卷积网络（DenseNet）来提取特征。而特征提取分支则是由多个卷积层和上下采样模块组成，用于生成不同分辨率的特征图。在特征融合阶段，PAN网络使用一种路径聚合的方法来将不同分辨率的特征图融合起来。具体来说，它将不同分辨率的特征图按照尺寸进行配对，然后使用一系列的卷积层来将它们融合起来。 通过使用PAN技术，YOLOv3算法可以处理不同大小的目标，提高了检测精度和稳定性。","link":"/2022/12/31/Algorithm_1_Yolo/"},{"title":"大二课程：数字图像处理","text":"大作业：基于Matlab对比Roberts、Prewitt、Sobel算子的区别（点击查看课题报告） 大作业：基于 Matlab 语言环境探究Candy边缘检测算子原理及应用（点击查看课题报告） 主要学习内容： MATLAB与图像相关的基本使用方法; 图像侵蚀和膨胀； 学习使用均值滤波器、中止滤波器处理图像噪声； 图像锐化：拉普拉斯算子、Roberts、Sobel 和 Prewitt 算子； 数字图像插值：隔行隔列抽取缩减图像、最邻近插值法放大图像、双线性插值法(bilinear)对图像进行插值放大； 基于直方图的数字图像检索 ： 首先分别统计R G B层对应0~255像素个数，并形成直方图 使用欧式距离，分析图像相似程度并安相似度排序输出，本实验仅对欧氏距离的结果进行排序，所以为了简化运算，减少程序运行开销，未进行最后的根式运算。 基于帧间差分的运动目标检测与跟踪系统：","link":"/2020/12/31/Lessons_1_DigitalImageProcessingUsingMATLAB/"}],"tags":[{"name":"About ME","slug":"About-ME","link":"/tags/About-ME/"},{"name":"图像算法","slug":"图像算法","link":"/tags/%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95/"},{"name":"本科课程","slug":"本科课程","link":"/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"}],"categories":[]}